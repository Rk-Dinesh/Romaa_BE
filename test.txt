import mongoose, { Schema } from "mongoose";

const userAttendanceSchema = new mongoose.Schema(
  {
    employeeId: {
      type: Schema.Types.ObjectId,
      ref: "Employee",
      required: true,
      index: true,
    },
    // Normalized Date (Midnight UTC)
    date: { type: Date, required: true },

    // --- 1. Shift Snapshot (Excellent, Keep this) ---
    shiftConfig: {
      shiftType: { type: String, enum: ["Fixed", "Rotational", "Flexible"], default: "Fixed" },
      startTime: { type: String }, // 09:00
      endTime: { type: String },   // 18:00
      gracePeriodMins: { type: Number }, 
      breakDurationMins: { type: Number, default: 90 }, // Expected break time
      isNightShift: { type: Boolean, default: false } // Critical for cross-day calculation
    },

    // --- 2. The Timeline (Multi-Punch Support) --- 
    // Captures every single event: In -> Break -> In -> Out
    timeline: [
      {
        punchType: { type: String, enum: ["In", "Out", "BreakStart", "LunchStart", "LunchEnd", "BreakEnd"] },
        timestamp: { type: Date, required: true },
        location: {
          lat: Number,
          lng: Number,
          address: String,
          accuracy: Number, // GPS Accuracy in meters
          isMock: { type: Boolean, default: false } // Android "Mock Location" detection
        },
        device: {
          deviceId: String,
          model: String,
          os: String,
          ip: String
        },
        verification: {
          method: { type: String, enum: ["Geofence", "Face", "Biometric", "Manual"], default: "Geofence" },
          confidenceScore: { type: Number }, // AI Face Match %
          photoUrl: String
        },
        geofenceSiteId: { type: Schema.Types.ObjectId, ref: "Tenders" },
        geofenceId: { type: Schema.Types.ObjectId, ref: "Geofence" },
        remarks: String,
        syncedAt: { type: Date }
      }
    ],

    // --- 3. [NEW] Session Tracking (Processed Intervals) ---
    // This is automatically calculated from the timeline whenever a punch happens.
    // Use this for Payroll/Charts instead of recalculating from timeline every time.
    sessions: [
      {
        startTime: { type: Date }, // e.g., 09:00 AM
        endTime: { type: Date },   // e.g., 01:00 PM (Lunch Start)
        durationMins: { type: Number, default: 0 }, // 240 mins
        type: { type: String, enum: ["Work", "Break", "Lunch"], default: "Work" },
        isBillable: { type: Boolean, default: true },
        isAutoClosed: { type: Boolean, default: false }, // If system auto-punched out
      }
    ],

    // --- 4. Calculated Summaries (Aggregated from Timeline) ---
    firstIn: { type: Date },  // The very first punch
    lastOut: { type: Date },  // The very last punch
    
    totalDuration: { type: Number, default: 0 }, // Raw time between First In and Last Out
    totalBreakTime: { type: Number, default: 0 }, // Time spent in breaks
    netWorkHours: { type: Number, default: 0 },   // (Total - Break) -> The "Payroll" hours
    
    overtimeHours: { type: Number, default: 0 },
    workType: { type: String, enum: ["Regular", "Overtime", "Holiday Work"], default: "Regular" },
    
    // --- 5. Status & Compliance ---
    status: {
      type: String,
      enum: ["Present", "Absent", "Half-Day", "On Leave", "Holiday", "Weekly Off", "Missed Punch"],
      default: "Absent",
    },
    attendanceType: {
      type: String,
      enum: ["Office", "Remote", "Field", "Hybrid","On Duty","Work From Home"],
      default: "Office"
    },
    
    // Flags for HR Reports
    flags: {
      isLateEntry: { type: Boolean, default: false },
      isEarlyExit: { type: Boolean, default: false },
      isAutoCheckOut: { type: Boolean, default: false }, // System auto-closed the day?
      hasDispute: { type: Boolean, default: false } // Employee raised a concern?
    },

    // --- 6. Regularization (Correction Workflow) ---
    regularization: {
      isApplied: { type: Boolean, default: false },
      status: { type: String, enum: ["Pending", "Approved", "Rejected"], default: "Pending" },
      reasonCategory: { type: String, enum: ["Missed Punch", "System Glitch", "Work From Home", "Client Visit","on leave"] },
      userReason: String,
      managerReason: String,
      originalData: { type: Object }, // Backup of data BEFORE correction
      correctedBy: { type: Schema.Types.ObjectId, ref: "Employee" },
      correctedAt: { type: Date }
    },

    // --- 7. Payroll & Locking (Critical for Salary Processing) ---
    payroll: {
      isLocked: { type: Boolean, default: false }, // True once salary is calculated
      batchId: { type: String }, // Link to the Payroll Run ID (e.g., "OCT_2026_BATCH_A")
      processedAt: { type: Date },
      
      // If penalties apply for this specific day
      penalty: {
        isApplied: { type: Boolean, default: false },
        type: { type: String, enum: ["Late Deduction", "Half-Day Absent", "No Pay"] },
        deductionAmount: { type: Number, default: 0 } // e.g., 0.5 days
      }
    },
    // --- 8. Credits & Accruals ---
    // Did working today earn them a leave for later?
    rewards: {
      isCompOffEligible: { type: Boolean, default: false },
      compOffCredit: { type: Number, default: 0 }, // e.g., 1 or 0.5
      expiryDate: { type: Date }, // When this specific credit expires
      approvalStatus: { type: String, enum: ["Auto-Approved", "Pending", "Rejected"] }
    },
    // --- 9. Employee Sentiment ---
    sentiment: {
      score: { type: Number, min: 1, max: 5 }, // 1 (Bad) to 5 (Great)
      tags: [{ type: String }], // ["Stressed", "Productive", "Sick"]
      capturedAt: { type: Date }
    }
  },
  { timestamps: true }
);

// âš¡ Performance Indexes
userAttendanceSchema.index({ employeeId: 1, date: 1 }, { unique: true }); // Prevent duplicates
userAttendanceSchema.index({ date: 1, status: 1 }); // "Who is absent today?"
userAttendanceSchema.index({ "flags.isLateEntry": 1 }); // "Late comers report"

const UserAttendanceModel = mongoose.model("UserAttendance", userAttendanceSchema);
export default UserAttendanceModel;


export const SHIFT_RULES = {
  // 1. Standard Day Shift (Fixed)
  // Logic: Late if after 09:15. Half-day if after 13:00.
  General: {
    code: "GS-01",
    type: "Fixed",
    startTime: "09:00",
    endTime: "18:00",
    gracePeriodMins: 15,    // Allowed until 09:15
    breakDurationMins: 60,  // Lunch Break
    isNightShift: false,    // Ends same day
    minHalfDayHours: 4,     // If worked < 4 hrs -> Absent
    minFullDayHours: 8,     // If worked < 8 hrs -> Half Day
    halfDayCutoff: "13:00"  // If punch-in after 13:00 -> Half Day
  },

  // 2. Evening/Swing Shift (Fixed)
  // Logic: Late if after 14:30.
  Evening: {
    code: "ES-01",
    type: "Fixed",
    startTime: "14:00",
    endTime: "23:00",
    gracePeriodMins: 30,    // Allowed until 14:30
    breakDurationMins: 45,
    isNightShift: false,    // Ends same day (just before midnight)
    minHalfDayHours: 4,
    minFullDayHours: 8,
    halfDayCutoff: "18:00"
  },

  // 3. Night Shift (Rotational / Cross-Day)
  // Logic: Starts today, ends tomorrow.
  Night: {
    code: "NS-01",
    type: "Rotational",
    startTime: "22:00",     // 10:00 PM
    endTime: "07:00",       // 07:00 AM (Next Day)
    gracePeriodMins: 30,    // Allowed until 22:30
    breakDurationMins: 60,
    isNightShift: true,     // <--- CRITICAL: Tells system to look at next date for checkout
    minHalfDayHours: 4.5,
    minFullDayHours: 8,
    halfDayCutoff: "02:00"  // 2 AM is the half-way point
  },

  // 4. Flexible / Startup Mode
  // Logic: No strict "Late". Just finish 9 hours total.
  Flexi: {
    code: "FLX-01",
    type: "Flexible",
    startTime: "08:00",     // Office opens
    endTime: "21:00",       // Office closes
    gracePeriodMins: 0,     // No concept of "Late" arrival
    breakDurationMins: 60,
    isNightShift: false,
    minHalfDayHours: 4.5,   // Minimum effort for half pay
    minFullDayHours: 9,     // Target duration
    coreHours: { start: "11:00", end: "16:00" } // Must be present
  }
};

i will import Shift rules from my Utils file and i will use it to calculate the attendance

  const { employeeId, latitude, longitude, siteLatitude, siteLongitude,attendanceType="Office",shiftType="Fixed"} = data;


const {
      employeeId,
      punchType = "In", // In, Out, BreakOut, BreakIn,LunchOut,LunchIn
      latitude,
      longitude,
      siteLatitude,
      siteLongitude,
      address,
      photoUrl,
      attendanceType = "Office", // Office, Remote, Field, On Duty
      shiftType = "General", // General, Evening, Night
      deviceId,
      deviceModel,
      ipAddress,
      geofenceId,
      geofenceSiteId,
      attendanceType = "Office", // Office, Remote, Site, On Duty 
    } = data;
