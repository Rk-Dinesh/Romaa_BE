Here is an task that , in schedule i want to control dates.

Dates: Parent Start = Min(Children Starts), Parent End = Max(Children Ends).

Quantity: Parent Quantity = Sum(Children Quantities).

Daily Logs: Parent Daily = Merge(Children Daily Logs).

Metrics: Calculate schedule_data for Parents based on the merged daily logs.

codes from Level 0 to Level 4

Level 0 is parent of Level 1 having serials A,B,C....
Level 1 is parent of Level 2 having serials 1,2,3....
Level 2 is parent of Level 3 having serials 1.1,1.2,1.3....
Level 3 is parent of Level 4 having serials 1.1.1,1.1.2,1.1.3....

Code,Description,Unit,Quantity
A,SITE ESTABLISHMENT,,
1,Soil Cutting,cum,10400
B,LHS-Side-Hight Portion,,
1,D/S Cut off Wall,,
1.1,Earthwork +49.2,,
1.1.1,ch 0-20,Rmt,100
1.1.2,ch 20-30,Rmt,15
1.1.3,ch 30-40,Rmt,10
,,,
1.2,PCC Top +49.3,,
1.2.1,ch 40-50,Rmt,55
1.2.2 ,ch 50-60,Rmt,60
2,Concrete Works,,
2.1,PCC,,
2.1.1,ch 60-85,Rmt,90
2.1.2,ch 85-120,Rmt,200
2.1.3,ch 120-125,Rmt,20
2.1.4,ch 125-130,Rmt,40

Three concepts to control dates.

In excel or csv upload i will upload start date , end date for each code. The revised_duration will be calculated automatically.


Predecessor: 

FS = Finish to Start
FF = Finish to Finish
SS = Start to Start
SF = Start to Finish

2FS+3 = 2nd row start date after date + 3 days 
3SS = 3rd row start date after date
3SS+2 = 3rd row start date after date + 2 days
4SS+1 = 4th row start date after date + 1 day
5SS-2 = 5th row start date after date - 2 days
5FF-2 = 5th row end date after date - 2 days

Update API:

Request Parameters
tender_id : Unique project identifier. As Params.
row_index : Index of the row to update. As Payload.
predessor: New predecessor in format  As Payload.
revised_duration: New duration in days. As Payload.
I want api to pass the below Conditions i structure

condition 1:

In payload predecessor , row_index given.

{
  "row_index": 7,
  "predecessor": "3FS+2",
}


Find the row at row_index in the schedule structure.
Update its predecessor using the predecessor from the payload.
Update its revised_start_date using the predecessor from the payload.
Example:
before 
// details of predecessor 3FS+1
row_index = 3
revised_start_date = 2025-01-01
revised_end_date = 2025-01-04 

row_index = 7
predecessor = "3FS+1"  for row_index = 7 
revised_start_date = 2025-01-06 // means 3FS+1 = 3rd row end date after date + 1 day = 2025-01-05 + 1 day = 2025-01-06
revised_end_date = 2025-01-11
revised_duration = 5
after
row_index = 7
predecessor = "3FS+2"
revised_start_date = 2025-01-07 // means 3FS+2 = 3rd row end date after date + 2 days = 2025-01-06 + 2 days = 2025-01-07
revised_end_date = 2025-01-12  // from revised_start_date + revised_duration = 2025-01-07 + 5 days = 2025-01-12

For all rows above the given row_index (i.e., with higher index):
If a row has a predecessor (FS/SS) starting from a row above the given row_index, update its dates using its own revised_duration from the structure.
If a row has a predecessor starting from a row below the given row_index, do not update its dates and proceed to the next row.
Repeat for all rows above the given row_index.

example:
before
row_index = 8
predecessor = "7FS"
revised_start_date = 2025-01-12 // means 7FS = 7th row end date after date + 1 day = 2025-01-11 + 1 day = 2025-01-12
revised_end_date = 2025-01-20 // from revised_start_date + revised_duration = 2025-01-12 + 8 days = 2025-01-20
revised_duration = 8
after
row_index = 8
predecessor = "7FS" , the predecessor 7FS has the 7th rowindex end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 , the predecossor row is above the row_index = 7.
// applicable for changeing the revised_start_date and revised_end_date based on the revised_duration
revised_start_date = 2025-01-13 // means 7FS = 7th row updated end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 
revised_end_date = 2025-01-21 // from revised_start_date + revised_duration = 2025-01-13 + 8 days = 2025-01-21
revised_duration = 8

row_index = 9
predecessor = "2FS" , the predecessor 2FS has the 2nd rowindex end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 , the predecessor row is below the row_index = 7.
//not applicable for changeing the revised_start_date and revised_end_date based on the revised_duration ,so omit this row.

row_index = 10
predecessor = "8FS+2" , the predecessor 8FS+2 has the 8th rowindex end date after date + 2 day = 2025-01-21  + 2 day = 2025-01-23 , the predecessor row is above the row_index = 7 .
// applicable for changeing the revised_start_date and revised_end_date based on the revised_duration
before
revised_start_date = 2025-01-23 // means 8FS+2 = 8th row old end date 2025-01-20 after date + 2 day = 2025-01-21 + 2 day = 2025-01-23 
revised_end_date = 2025-01-28 // from revised_start_date + revised_duration = 2025-01-23 + 5 days = 2025-01-28
revised_duration = 5

after
revised_start_date = 2025-01-24 // means 8FS+2 = 8th row updated end date 2025-01-21 after date + 2 day = 2025-01-22 + 2 day = 2025-01-24 
revised_end_date = 2025-01-29 // from revised_start_date + revised_duration = 2025-01-24 + 5 days = 2025-01-29
revised_duration = 5

like this so on,

condition 2:

In payload revised_duration , row_index given.

{
  "row_index": 7,
  "revised_duration": 6
}


Find the row at row_index in the schedule structure.
Update its revised_end_date using the provided revised_duration from the payload and calculate the lag (difference between revised_duration and the original duration from the structure).
row_index = 7 , revised_duration = 6 from payload
before
revised_start_date = 2025-01-06 
revised_end_date = 2025-01-11
revised_duration = 5
after
row_index = 7 
revised_start_date = 2025-01-06
revised_end_date = 2025-01-12  // from revised_start_date + revised_duration = 2025-01-06 + 6 days = 2025-01-12
revised_duration = 6
For all rows above the given row_index (i.e., with higher index):
If a row has a predecessor (FS/SS) starting from a row above the given row_index, update its dates using its own revised_duration from the structure.
If a row has a predecessor starting from a row below the given row_index, do not update its dates and proceed to the next row.
example:
before
row_index = 8
predecessor = "7FS"
revised_start_date = 2025-01-12 // means 7FS = 7th row end date after date + 1 day = 2025-01-11 + 1 day = 2025-01-12
revised_end_date = 2025-01-20 // from revised_start_date + revised_duration = 2025-01-12 + 8 days = 2025-01-20
revised_duration = 8
after
row_index = 8
predecessor = "7FS" , the predecessor 7FS has the 7th rowindex end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 , the predecossor row is above the row_index = 7.
// applicable for changeing the revised_start_date and revised_end_date based on the revised_duration
revised_start_date = 2025-01-13 // means 7FS = 7th row updated end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 
revised_end_date = 2025-01-21 // from revised_start_date + revised_duration = 2025-01-13 + 8 days = 2025-01-21
revised_duration = 8

row_index = 9
predecessor = "2FS" , the predecessor 2FS has the 2nd rowindex end date after date + 1 day = 2025-01-12 + 1 day = 2025-01-13 , the predecessor row is below the row_index = 7.
//not applicable for changeing the revised_start_date and revised_end_date based on the revised_duration ,so omit this row.

row_index = 10
predecessor = "8FS+2" , the predecessor 8FS+2 has the 8th rowindex end date after date + 2 day = 2025-01-21  + 2 day = 2025-01-23 , the predecessor row is above the row_index = 7 .
// applicable for changeing the revised_start_date and revised_end_date based on the revised_duration
before
revised_start_date = 2025-01-23 // means 8FS+2 = 8th row old end date 2025-01-20 after date + 2 day = 2025-01-21 + 2 day = 2025-01-23 
revised_end_date = 2025-01-28 // from revised_start_date + revised_duration = 2025-01-23 + 5 days = 2025-01-28
revised_duration = 5

after
revised_start_date = 2025-01-24 // means 8FS+2 = 8th row updated end date 2025-01-21 after date + 2 day = 2025-01-22 + 2 day = 2025-01-24 
revised_end_date = 2025-01-29 // from revised_start_date + revised_duration = 2025-01-24 + 5 days = 2025-01-29
revised_duration = 5

like this so on,

simultaneously update the needed metrics on row and do the calculation metrics.
Update the needed metrics to have better performance & data accuracy & fast api response.


In Project Schedule , it has rows as row_index.
I want an Action Button (edit) only on the row_index that the start_date,end_date and duration ,predecessor are not null.
Onclick the button it should open a modal with the row_index data.row_index, item_name,unit,quantity,start_date,end_date as readonly.duration, predecessor as editable.
 There user has an either to edit duration or predecessor.

 on submit the payload should be like this:

 if duration is edited
{
  "row_index": 7,
  "revised_duration": 6
}

or
if predecessor is edited
{
  "row_index": 7,
  "predecessor": "8FS+2"
}

Summary work flow:
1. Two types of Employees:
    a.office Staff
    b.NMR Staff

Here we will maintain the attendance of both types of employees.Payroll will be calculated based on the attendance.
Location based attendance.if the employee is in office location then the attendance will be marked as office
Leave Management

This above segment is for the  HR & Labour Management Schedule.

2. Assing Roles to Employees for Login of Dashboard.

Here we will assign roles to employees for login of dashboard.
Roles will be created by the user and assigned to employees.we can allocate them the access to the modules. like site,project,tender,employee,attendance etc.


static async applyLeave(data) {
    let { 
      employeeId, leaveType, requestType, fromDate, toDate, 
      reason, shortLeaveTime, coveringEmployeeId 
    } = data;

    // A. Validate Dates
    const start = new Date(fromDate);
    const end = new Date(toDate);
    start.setUTCHours(0, 0, 0, 0);
    end.setUTCHours(0, 0, 0, 0);

    if (start > end) throw { statusCode: 400, message: "End date cannot be before start date." };

    // Helper to format dates nicely
    const dateStr = (d) => new Date(d).toLocaleDateString("en-GB"); // DD/MM/YYYY

    // ---------------------------------------------------------
    // ðŸš€ B. CALCULATE ACTUAL LEAVE DAYS (Server-Side Logic)
    // ---------------------------------------------------------
    let calculatedDays = 0;
    let loopDate = new Date(start);
    
    // Store details of why days were skipped
    const nonWorkingLog = []; 

    while (loopDate <= end) {
      const dayStatus = await CalendarService.checkDayStatus(loopDate);

      if (dayStatus.isWorkingDay) {
        // It is a working day, calculate count
        if (requestType === "First Half" || requestType === "Second Half") {
          calculatedDays += 0.5;
        } else {
          calculatedDays += 1;
        }
      } else {
        // It is a Holiday/Weekend, record the reason
        nonWorkingLog.push(`${dateStr(loopDate)}: ${dayStatus.reason}`);
      }

      loopDate.setDate(loopDate.getDate() + 1);
    }

    // ðŸ›‘ ERROR IF 0 DAYS (Detailed Explanation)
    if (calculatedDays === 0) {
      const details = nonWorkingLog.join(", ");
      throw { 
        statusCode: 400, 
        message: `No leave needed. All selected dates are holidays/offs: [ ${details} ]` 
      };
    }

    // ---------------------------------------------------------

    // C. Check Leave Balance
    const employee = await EmployeeModel.findById(employeeId);
    if (!employee) throw { statusCode: 404, message: "Employee not found." };

    const currentBalance = employee.leaveBalance[leaveType]; 
    if (leaveType !== "LWP" && currentBalance < calculatedDays) {
      throw { statusCode: 400, message: `Insufficient ${leaveType} balance. Need: ${calculatedDays}, Available: ${currentBalance}` };
    }

    // D. Check for Overlapping Requests
    const overlap = await LeaveRequestModel.findOne({
      employeeId,
      status: { $in: ["Pending", "Manager Approved", "HR Approved", "Approved"] }, 
      $or: [
        { fromDate: { $lte: end }, toDate: { $gte: start } }
      ]
    });

    if (overlap) {
      const conflictStart = dateStr(overlap.fromDate);
      const conflictEnd = dateStr(overlap.toDate);
      throw { 
        statusCode: 409, 
        message: `Overlap Detected: You already have a '${overlap.status}' request for ${overlap.leaveType} from ${conflictStart} to ${conflictEnd}.` 
      };
    }

    // E. Create Request
    const newLeave = new LeaveRequestModel({
      employeeId,
      leaveType,
      requestType,
      fromDate: start,
      toDate: end,
      totalDays: calculatedDays,
      reason,
      shortLeaveTime,
      coveringEmployeeId,
      status: "Pending",
      workflowLogs: [{
        action: "Applied",
        actionBy: employeeId,
        role: "Employee",
        remarks: reason
      }]
    });

    await newLeave.save();
    return newLeave;
  }